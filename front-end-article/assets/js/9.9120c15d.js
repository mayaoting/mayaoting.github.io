(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{367:function(a,e,l){"use strict";l.r(e);var t=l(42),n=Object(t.a)({},(function(){var a=this,e=a.$createElement,l=a._self._c||e;return l("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[l("h2",{attrs:{id:"webpack-loader"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#webpack-loader"}},[a._v("#")]),a._v(" webpack loader")]),a._v(" "),l("p",[a._v("loader 用于对模块的源代码进行转换。loader 可以使你在 import 或 '加载'模块时预处理文件。因此,loader 类似于其他构建工具中 “任务(task)”,并提供了处理前端构建步骤的强大方法。 loader 可以将文件从不同的语言（如 Typescript）转换为 javaScript ，或将内联图像转换为 data URL")]),a._v(" "),l("ul",[l("li",[a._v("loader 支持链式传递，且执行顺序是自下而上的执行，loader 链中的第一个 loader 返回值给下一个 loader,在最后一个 loader， 返回 webpack 所预期的 JavaScript")]),a._v(" "),l("li",[a._v("loader 可以是同步的也可以是异步的")])]),a._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[a._v("// webpack.config.js\nmodule: {\n    rules: [{\n      test: /\\.js$/, // 表示对js文件使用下面的两个loader\n      // 当链式调用多个loader的时候 他们会以相反的顺序执行 自下而上  即先用loader处理源码，然后在处理后代码再传给 loader2\n      use: [{\n          loader: path.resolve('./src/loader2.js'),\n        },\n        {\n          loader: path.resolve('./src/loader1.js'),\n        }\n      ]\n    }]\n  },\n")])])]),l("h2",{attrs:{id:"webpack-plugin"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#webpack-plugin"}},[a._v("#")]),a._v(" webpack plugin")]),a._v(" "),l("p",[a._v("webpack 插件是一个具有 apply 方法的 javaScript 对象 apply 方法\n会被 webpack compiler 调用并且在整个编译生命周期都可以访问\ncompiler 对象")]),a._v(" "),l("ul",[l("li",[a._v("一个 javaScript 命名函数")]),a._v(" "),l("li",[a._v("在插件函数的 prototype 上定义一个 apply 方法")]),a._v(" "),l("li",[a._v("指定一个绑定到 webapck 自身的事件钩子")]),a._v(" "),l("li",[a._v("处理 webpack 内部实例的特定数据")]),a._v(" "),l("li",[a._v("功能完成后调用 webpack 提供的回调")])]),a._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[a._v("// 一个javaScript命名的函数\nfunction Plugin(option) {}\n\n// 在插件函数的prototype上定一个apply方法\nPlugin.prototype.apply = function(compiler) {\n// 指定一个挂载到webpack自身的事件钩子\ncompiler.plugin('webpacksEventHook',funtion(compilation) {\n  // 处理webpack内部实例的特定数据\n  console.log(\"this is an example plugin!!!)\n  //功能完成后调用webpack 提供的回调\n  callback()\n})\n}\n")])])])])}),[],!1,null,null,null);e.default=n.exports}}]);